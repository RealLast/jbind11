#pragma once

#include "AbstractJavaFunction.hpp"
#include "JBindWrapper/FunctionGenerator.hpp"
#include "TemplatePackUtils/TemplatePackUtils.hpp"

#include <functional>
#include "cast.hpp"
namespace jbind11
{
    template<bool IsStatic, typename Class, typename Return, typename... Params>
    class JavaFunction : public AbstractJavaFunction
    {
        private:
            typedef std::tuple<Params...> Tuple;
            typedef Return (Class::*Function)(Params...); // Defines type Function (a bit confusing syntax).

            Function function;
            std::string functionName;

            template<int C, typename I, typename... Is>
            void javaArrayListToStdTuple(JavaArrayList& arrayList, Tuple& tuple)
            {
                std::get<C>(tuple) = fromJavaObject<I>(arrayList.get(C));
                javaArrayListToStdTuple<C + 1, Is...>(arrayList, tuple);
            }

            template<int C>
            void javaArrayListToStdTuple(JavaArrayList& arrayList, Tuple& tuple)
            {
                // Base case
            }

            void verifyStack(JavaArrayList& stack)
            {
                if(stack.size() != sizeof...(Params))
                {
                    JBIND_THROW("Cannot invoke function \"" << functionName << "\".\n"
                        << "This function has " << sizeof...(Params) 
                            << "parameters, but only " << stack.size() << " were provided.");
                }
            }

            template<typename U = Return>
            typename std::enable_if<IsStatic, U>::type
            apply(Function& function, Class& instance, Tuple& stack)
            {
                // Bind pointer-to-static-member-function in std::function.
                std::function<Return(Params...)> func = 
                    TemplatePackUtils::bind_with_variadic_placeholders<Class, Return, Params...> (function);

                // If C++17, we can use std::apply.
                // < C++17 we need to do it manually.
                return TemplatePackUtils::applyTupleToStdFunction<Return>(stack, func);
            }

            template<typename U = Return>
            typename std::enable_if<!IsStatic, U>::type
            apply(Function& function, Class& instance, Tuple& stack)
            {
                // Bind pointer-to-member-function and instance in function.
                // Therefore, we do not need to pass instance to applyTupleToStdFunction().
                // Makes the TemplatePackUtils a bit prettier..
                std::function<Return(Params...)> func = 
                    TemplatePackUtils::bind_with_variadic_placeholders<Class, Return, Params...> (function, &instance);

                // If C++17, we can use std::apply.
                // < C++17 we need to do it manually.
                return TemplatePackUtils::applyTupleToStdFunction<Return>(stack, func);
            }

            template<typename U = Return>
            typename std::enable_if<!std::is_void<U>::value, jobject>::type
            invoke(Class& instance, Tuple& invocationStack)
            {
                Return r = apply(function, instance, invocationStack);
                return cast(r);
            }

            template<typename U = Return>
            typename std::enable_if<std::is_void<U>::value, jobject>::type
            invoke(Class& instance, Tuple& invocationStack)
            {
                apply(function, instance, invocationStack);
                return nullptr;
            }


        
        public:
            JavaFunction()
            {

            }

            JavaFunction(std::string& functionName, Function function) : functionName(functionName), function(function)
            {

            }

        
            jobject execute(JavaHandle handle, JavaArrayList stack)
            {
                verifyStack(stack);
                std::tuple<Params...> invocationStack;
                javaArrayListToStdTuple<0, Params...>(stack, invocationStack);

                Class& instance = *handle.getNativeData<Class>();

                // You might wonder, why we do not distinguish between 
                // invoking a static vs. non-static function here.
                // Because the way jbind11 works, each java class
                // generated by jbind11 always has an associated handle,
                // even if the class purely consists of only static functions.
                // Hence, an instance is always available.
                // The differentiation happens in the "apply" function above,
                // where the handle is discarded if IsStatic = true.
                return invoke<Return>(instance, invocationStack);
            }

            // template<typename U = Return>
            // typename std::enable_if<std::is_void<U>::value, jobject>::type
            // execute(JavaArrayList stack)
            // {
            //     verifyStack(stack);
            //     std::tuple<Params...> invocationStack;
            //     javaArrayListToStdTuple<0, Params...>(stack, invocationStack);
            //    // apply(invocationStack, function);

            //     // Is void function, no object to return.
            //     return nullptr;
            // }

            std::string getFunctionDefinition()
            {
                return FunctionGenerator<Return, Params...>::generate(functionName);
            }

    };
}